{"ast":null,"code":"'use strict';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar invariant = require('invariant');\n\nvar Animated = require('./Animated');\n\nvar AnimatedValue = require('./AnimatedValue');\n\nvar AnimatedValueXY = require('./AnimatedValueXY');\n\nvar AnimatedAddition = require('./AnimatedAddition');\n\nvar AnimatedMultiplication = require('./AnimatedMultiplication');\n\nvar AnimatedModulo = require('./AnimatedModulo');\n\nvar AnimatedTemplate = require('./AnimatedTemplate');\n\nvar AnimatedTracking = require('./AnimatedTracking');\n\nvar isAnimated = require('./isAnimated');\n\nvar Animation = require('./Animation');\n\nvar TimingAnimation = require('./TimingAnimation');\n\nvar DecayAnimation = require('./DecayAnimation');\n\nvar SpringAnimation = require('./SpringAnimation');\n\nvar maybeVectorAnim = function maybeVectorAnim(value, config, anim) {\n  if (value instanceof AnimatedValueXY) {\n    var configX = _extends({}, config);\n\n    var configY = _extends({}, config);\n\n    for (var key in config) {\n      var _config$key = config[key],\n          x = _config$key.x,\n          y = _config$key.y;\n\n      if (x !== undefined && y !== undefined) {\n        configX[key] = x;\n        configY[key] = y;\n      }\n    }\n\n    var aX = anim(value.x, configX);\n    var aY = anim(value.y, configY);\n    return parallel([aX, aY], {\n      stopTogether: false\n    });\n  }\n\n  return null;\n};\n\nvar spring = function spring(value, config) {\n  return maybeVectorAnim(value, config, spring) || {\n    start: function start(callback) {\n      var singleValue = value;\n      var singleConfig = config;\n      singleValue.stopTracking();\n\n      if (config.toValue instanceof Animated) {\n        singleValue.track(new AnimatedTracking(singleValue, config.toValue, SpringAnimation, singleConfig, callback));\n      } else {\n        singleValue.animate(new SpringAnimation(singleConfig), callback);\n      }\n    },\n    stop: function stop() {\n      value.stopAnimation();\n    }\n  };\n};\n\nvar timing = function timing(value, config) {\n  return maybeVectorAnim(value, config, timing) || {\n    start: function start(callback) {\n      var singleValue = value;\n      var singleConfig = config;\n      singleValue.stopTracking();\n\n      if (config.toValue instanceof Animated) {\n        singleValue.track(new AnimatedTracking(singleValue, config.toValue, TimingAnimation, singleConfig, callback));\n      } else {\n        singleValue.animate(new TimingAnimation(singleConfig), callback);\n      }\n    },\n    stop: function stop() {\n      value.stopAnimation();\n    }\n  };\n};\n\nvar decay = function decay(value, config) {\n  return maybeVectorAnim(value, config, decay) || {\n    start: function start(callback) {\n      var singleValue = value;\n      var singleConfig = config;\n      singleValue.stopTracking();\n      singleValue.animate(new DecayAnimation(singleConfig), callback);\n    },\n    stop: function stop() {\n      value.stopAnimation();\n    }\n  };\n};\n\nvar sequence = function sequence(animations) {\n  var current = 0;\n  return {\n    start: function start(callback) {\n      var onComplete = function onComplete(result) {\n        if (!result.finished) {\n          callback && callback(result);\n          return;\n        }\n\n        current++;\n\n        if (current === animations.length) {\n          callback && callback(result);\n          return;\n        }\n\n        animations[current].start(onComplete);\n      };\n\n      if (animations.length === 0) {\n        callback && callback({\n          finished: true\n        });\n      } else {\n        animations[current].start(onComplete);\n      }\n    },\n    stop: function stop() {\n      if (current < animations.length) {\n        animations[current].stop();\n      }\n    }\n  };\n};\n\nvar parallel = function parallel(animations, config) {\n  var doneCount = 0;\n  var hasEnded = {};\n  var stopTogether = !(config && config.stopTogether === false);\n  var result = {\n    start: function start(callback) {\n      if (doneCount === animations.length) {\n        callback && callback({\n          finished: true\n        });\n        return;\n      }\n\n      animations.forEach(function (animation, idx) {\n        var cb = function cb(endResult) {\n          hasEnded[idx] = true;\n          doneCount++;\n\n          if (doneCount === animations.length) {\n            doneCount = 0;\n            callback && callback(endResult);\n            return;\n          }\n\n          if (!endResult.finished && stopTogether) {\n            result.stop();\n          }\n        };\n\n        if (!animation) {\n          cb({\n            finished: true\n          });\n        } else {\n          animation.start(cb);\n        }\n      });\n    },\n    stop: function stop() {\n      animations.forEach(function (animation, idx) {\n        !hasEnded[idx] && animation.stop();\n        hasEnded[idx] = true;\n      });\n    }\n  };\n  return result;\n};\n\nvar delay = function delay(time) {\n  return timing(new AnimatedValue(0), {\n    toValue: 0,\n    delay: time,\n    duration: 0\n  });\n};\n\nvar stagger = function stagger(time, animations) {\n  return parallel(animations.map(function (animation, i) {\n    return sequence([delay(time * i), animation]);\n  }));\n};\n\nvar event = function event(argMapping, config) {\n  return function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var traverse = function traverse(recMapping, recEvt, key) {\n      if (typeof recEvt === 'number') {\n        invariant(recMapping instanceof AnimatedValue, 'Bad mapping of type ' + typeof recMapping + ' for key ' + key + ', event value must map to AnimatedValue');\n        recMapping.setValue(recEvt);\n        return;\n      }\n\n      invariant(typeof recMapping === 'object', 'Bad mapping of type ' + typeof recMapping + ' for key ' + key);\n      invariant(typeof recEvt === 'object', 'Bad event of type ' + typeof recEvt + ' for key ' + key);\n\n      for (var key in recMapping) {\n        traverse(recMapping[key], recEvt[key], key);\n      }\n    };\n\n    argMapping.forEach(function (mapping, idx) {\n      traverse(mapping, args[idx], 'arg' + idx);\n    });\n\n    if (config && config.listener) {\n      config.listener.apply(null, args);\n    }\n  };\n};\n\nmodule.exports = {\n  Value: AnimatedValue,\n  ValueXY: AnimatedValueXY,\n  decay: decay,\n  timing: timing,\n  spring: spring,\n  add: function add(a, b) {\n    return new AnimatedAddition(a, b);\n  },\n  multiply: function multiply(a, b) {\n    return new AnimatedMultiplication(a, b);\n  },\n  modulo: function modulo(a, modulus) {\n    return new AnimatedModulo(a, modulus);\n  },\n  template: function template(strings) {\n    for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      values[_key2 - 1] = arguments[_key2];\n    }\n\n    return new AnimatedTemplate(strings, values);\n  },\n  delay: delay,\n  sequence: sequence,\n  parallel: parallel,\n  stagger: stagger,\n  event: event,\n  isAnimated: isAnimated,\n  createAnimatedComponent: require('./createAnimatedComponent'),\n  inject: {\n    ApplyAnimatedValues: require('./injectable/ApplyAnimatedValues').inject,\n    InteractionManager: require('./injectable/InteractionManager').inject,\n    FlattenStyle: require('./injectable/FlattenStyle').inject,\n    RequestAnimationFrame: require('./injectable/RequestAnimationFrame').inject,\n    CancelAnimationFrame: require('./injectable/CancelAnimationFrame').inject\n  },\n  __PropsOnlyForTests: require('./AnimatedProps')\n};","map":null,"metadata":{},"sourceType":"script"}